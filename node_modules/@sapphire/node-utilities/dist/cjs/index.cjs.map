{"version":3,"sources":["../../src/lib/findFilesRecursively.ts"],"names":[],"mappings":";;;;AACA,SAAS,eAAe;AACxB,SAAS,YAAY;AA2BrB,gBAAuB,qBAAqB,MAAgB,YAA2C,MAAM,MAAqC;AACjJ,QAAM,MAAM,MAAM,QAAQ,IAAI;AAE9B,mBAAiB,QAAQ,KAAK;AAC7B,QAAI,KAAK,OAAO,KAAK,UAAU,KAAK,IAAI,GAAG;AAC1C,YAAM,KAAK,IAAI,MAAM,KAAK,IAAI;AAAA,IAC/B,WAAW,KAAK,YAAY,GAAG;AAC9B,aAAO,qBAAqB,KAAK,IAAI,MAAM,KAAK,IAAI,GAAG,SAAS;AAAA,IACjE;AAAA,EACD;AACD;AAVuB;AAqBhB,SAAS,qCAAqC,MAAgB,gBAAwB;AAC5F,SAAO,qBAAqB,MAAM,CAAC,aAAa,SAAS,WAAW,cAAc,CAAC;AACpF;AAFgB;AAcT,SAAS,mCAAmC,MAAgB,cAAsB;AACxF,SAAO,qBAAqB,MAAM,CAAC,aAAa,SAAS,SAAS,YAAY,CAAC;AAChF;AAFgB;AAYT,SAAS,mCAAmC,MAAgB,SAAiB;AACnF,SAAO,qBAAqB,MAAM,CAAC,aAAa,SAAS,SAAS,OAAO,CAAC;AAC3E;AAFgB;AAUT,SAAS,0BAA0B,MAAgB,OAAe;AACxE,SAAO,qBAAqB,MAAM,CAAC,aAAa,MAAM,KAAK,QAAQ,CAAC;AACrE;AAFgB","sourcesContent":["import type { PathLike } from 'node:fs';\nimport { opendir } from 'node:fs/promises';\nimport { join } from 'node:path';\n\n/**\n *\n * @param path The path in which to find files.\n * @param predicate A predicate function receives the path as a parameter. Truthy values will have the path included, falsey values will have the file excluded.\n *\n * @return An {@link AsyncIterableIterator} of all the files. To loop over these use `for await (const file of findFilesRecursively(path, predicate)) {}`\n *\n * @example\n * ```typescript\n * // With CommonJS: To find all files ending with `.ts` in the src directory:\n * const path = require('node:path');\n *\n * for await (const file of findFilesRecursively(path.join(__dirname, 'src'), (filePath) => filePath.endsWith('.ts'))) {\n *   console.log(file);\n * }\n * ```\n *\n * @example\n * ```typescript\n * // With ESM: To find all files ending with `.ts` in the src directory:\n * for await (const file of findFilesRecursively(new URL('src', import.meta.url), (filePath) => filePath.endsWith('.ts'))) {\n *   console.log(file);\n * }\n * ```\n */\nexport async function* findFilesRecursively(path: PathLike, predicate: (filePath: string) => boolean = () => true): AsyncIterableIterator<string> {\n\tconst dir = await opendir(path);\n\n\tfor await (const item of dir) {\n\t\tif (item.isFile() && predicate(item.name)) {\n\t\t\tyield join(dir.path, item.name);\n\t\t} else if (item.isDirectory()) {\n\t\t\tyield* findFilesRecursively(join(dir.path, item.name), predicate);\n\t\t}\n\t}\n}\n\n/**\n *\n * @param path The path in which to find files. This can be a string, buffer, or {@link URL}.\n * @param fileStartsWith The string pattern with which the file name must start.\n *\n * Note that we do **not** support a full globby pattern using asterisk for wildcards. It has to be an exact match with {@link String.startsWith}\n *\n * @return An {@link AsyncIterableIterator} of all the files. To loop over these use `for await (const file of findFilesRecursivelyStringStartsWith(path, fileNameEndsWith)) {}`\n */\nexport function findFilesRecursivelyStringStartsWith(path: PathLike, fileStartsWith: string) {\n\treturn findFilesRecursively(path, (filePath) => filePath.startsWith(fileStartsWith));\n}\n\n/**\n *\n * @param path The path in which to find files. This can be a string, buffer, or {@link URL}.\n * @param fileEndsWith The string pattern with which the file name must end.\n * Ideally this is a file extension, however you can also provide more parts of the end of the file.\n *\n * Note that we do **not** support a full globby pattern using asterisk for wildcards. It has to be an exact match with {@link String.endsWith}\n *\n * @return An {@link AsyncIterableIterator} of all the files. To loop over these use `for await (const file of findFilesRecursivelyStringEndsWith(path, fileNameEndsWith)) {}`\n */\nexport function findFilesRecursivelyStringEndsWith(path: PathLike, fileEndsWith: string) {\n\treturn findFilesRecursively(path, (filePath) => filePath.endsWith(fileEndsWith));\n}\n\n/**\n * @param path The path in which to find files. This can be a string, buffer, or {@link URL}.\n * @param include The string pattern which must be present in the file name.\n *\n * Note that we do **not** support a full globby pattern using asterisk for wildcards. It has to be an exact match with {@link String.includes}\n *\n * @return An {@link AsyncIterableIterator} of all the files. To loop over these use `for await (const file of findFilesRecursivelyStringIncludes(path, fileNameEndsWith)) {}`\n */\nexport function findFilesRecursivelyStringIncludes(path: PathLike, include: string) {\n\treturn findFilesRecursively(path, (filePath) => filePath.includes(include));\n}\n\n/**\n * @param path The path in which to find files. This can be a string, buffer, or {@link URL}.\n * @param regex The regex pattern that the file name must match.\n *\n * @return An {@link AsyncIterableIterator} of all the files. To loop over these use `for await (const file of findFilesRecursivelyRegex(path, fileNameEndsWith)) {}`\n */\nexport function findFilesRecursivelyRegex(path: PathLike, regex: RegExp) {\n\treturn findFilesRecursively(path, (filePath) => regex.test(filePath));\n}\n"]}